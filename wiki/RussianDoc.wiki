== Hello, World! ==
{{{
public class HelloWorld {
    static {
        ScriptJava.window.alert("Hello, World!");
    }
}
}}}

После компиляции (о чем написано ниже), включения полученного .js файла на html страничку и открытия её в браузере вы скорее всего увидите окошко с "Hello, World!"
Компиляция  

Компиляция это процесс запуска Java программы. Компилятор - это java программа, в которой перечисленны java классы, которые нужно скомпилить.
Вот пример, который скомпилит HelloWorld:

{{{
public class HelloWorldCompiler extends CommonCompiler {	
    @Override
    public void addToCompiler(Compiler compiler) throws Exception {
        compiler
            .setPathPrefix("src/")
            .parseClass(HelloWorld.class);
    }

    public static void main(String[] args) throws Exception {
        new Compiler().build(args);
    }
}
}}}
А запускать это компилятор надо вот с какими параметрами:

java -cp ... HelloWorldCompiler -basePath ../Market/svn-market/libraries/trunk/strict-web/src/java/

Параметр запуска basePath - это путь к тому месту, где лежат исходники strict-web, потому что во время компиляции они читаются

Поскольку наш пример - это всего одни java класс, то вы найдете только один вызов метода parseClass, а если классов будет много (как в gurulight)
то вызовов будет много.


В результате в конце сгенерированного файла (имя по умолчанию generated.js) вы сможете увидеть:

{{{
{
ScriptJava.window.alert('Hello, World!');
}
}}}

Из чего можно сделать вот какой вывод: *точка входа программы - это статические конструкторы классов*
Выполняются они в то же порядке, в котором перечислены при компиляции


Если вам надо результирующий файл положить куда-то именно, то запускать компилятор можно с опцией -jsGenPath
Hint: в качестве пути, можно указать Samba-путь на сервер, например -jsGenPath //asgard/hoota/www/mbo/gurulight/generated.js

== Примеры ==

Все примеры так же можно найти в пакете. Или [Examples тут]

== Ajax ==

Основные моменты:

 * ajax вызовы идут между клиентом и сервером
 * ajax вызов в понимании strictweb - это вызов метода серверного класса, и получение от него результатов
 * ajax вызовы бывают двух типов - синхронные и асинхронные
 * ajax вызов не возвращает html или xml - он возвращает данные (модель), и по ним, если надо строится интерфейс

Серверный класс нужно дополнить аннотацией `@AjaxServiceHelper`, и сказать компилятору, чтобы он компилировался, наряду со всеми другими классами. Компилятор поймет (по аннотации), что это серверный класс и сгенерит для него stub-обертку. Эта обертка - набор методов, которые заворачиваются входные параметры в метод `Ajax.syncCall`, не смотрите на `syncCall` - это старое название, этот метод может делать как sync так и async вызовы. Каждый метод, который вы хотите сделать открытым для вызова через ajax нужно дополнить аннотацией `@Arguments`


Пример серверного класса и метода:
{{{
@AjaxServiceHelper(description = "Пример серверного класса")
public class SampleHelperBean {
    @Arguments
    public Date getServerDate() {
        return new Date();
    }
...
}
}}}

Пример синхронного вызова этого метода с клиентской стороны:

{{{
SampleHelperBean helper = new SampleHelperBean(); // эту переменную можно вынести в статические поля клиентского класса
...
window.alert(helper.getServerDate());
}}}

Пример асинхронного вызова:
{{{
ajaxAsyncCall(helper.getServerDate(), new VoidDelegate<Date>() {
    public void voidDelegate(Date date) {
        window.alert(dateToStringSmart(date));
    }
});
}}}
`ajaxAsyncCall` - это еще один магический метод. Второй аргумент он передает в Ajax.syncCall в качестве callback слушателя.

== Ajax и сериализация результата ==

Результат отдается от сервера ввиде JSON. Типа JSON, но не совсем. Чистый JSON не позволяет сериализовать рекурсивные структуры. Но то, что сделано в Strict Web - оно сериализует такое отлично. Сериализуются почти любые данные, почти любые бины, структуры и т.п. Если что-то не удалось сериализовать, тогда используйте аннотацию @Presentable около класса, полей или методов. И будет вам счастье.